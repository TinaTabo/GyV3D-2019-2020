<!--
  Práctica final GyV3D Cristina Taboada Mayo
  Partes implementadas:
    - Funcionalidad básica.
-->
<!DOCTYPE html>
<html>

  <head>
    <title>Práctica Final: 3D-Pong</title>

    <style>
    * {
    	margin: 0px;
    }
    </style>

    <!-- Incorporamos las librerias -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/103/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.6/dat.gui.min.js"></script>
    <!-- MUY IMPORTANTE: tenemos que tener descargada esta libreria para poder llamarla
         de esta manera, sino no funciona.-->
    <script src="js/physi.js"></script>

    <!-- Script principal, donde se va a realizar toda la programación javascript -->
    <script>
       // Hilo secundario que realiza los calculos de physi.js
       Physijs.scripts.worker = 'js/physijs_worker.js';

       // Función que será llamada desde el body html y que cargará el juego.
       function init() {
          // Creamos la escena.
          var scene = new Physijs.Scene;
          // Se simula la fuerza de la gravedad con  un vector en la escena.
          scene.setGravity(new THREE.Vector3(0, -10, 0));

          // Como canvas vamos a utilizar el propio de html.
          var sceneWidth = window.innerWidth;
          var sceneHeight = window.innerHeight;

          // Creamos la cámara y definimos: su posición, donde enfoca (en este caso al centro
          // de la escena -> lookAt)
          var camera = new THREE.PerspectiveCamera(90, sceneWidth / sceneHeight, 0.01, 100);
          camera.position.set(0, -10, 15);
          camera.lookAt(scene.position);

          // Creamos el renderizador.
          var renderer = new THREE.WebGLRenderer({
             antialias : true
          });
          // Le decimos que renderice las sombras.
          renderer.shadowMap.enabled = true;
          // Le decimos al renderizador el tamaño del frame que tiene que renderizar.
          renderer.setSize(sceneWidth, sceneHeight);
          // Como no hemos creado un canvas, tenemos que añadir la escena al html
          // Esto se hace llamando a esta funcion.
          // Añade al html su propio canvas.
          document.body.appendChild(renderer.domElement);

          // Varibles que cargan cada objeto:
          var light = getLight();
          var floor = getFloor();
          var sphere = getSphere();
          var leftBorder = getBorder("left", 1, 20, 5, -7.5, 0, 0);
          var rightBorder = getBorder("right", 1, 20, 5, 7.5, 0, 0);
          var cpu = getBorder("top", 5, 1, 3, 0, 11, 0);
          var user = getBorder("down", 5, 1, 3, 0, -11, 0);

          // Añadimos a la escena cada objeto:
          scene.add(light);
          scene.add(floor);
          scene.add(sphere);
          scene.add(leftBorder);
          scene.add(rightBorder);
          scene.add(cpu);
          scene.add(user);

          // Llamamos a la funcion para que haga la animacion.
          animate(sphere, renderer, scene, camera);
       }

       // A esta funcion le pasamos la malla, el renderizador, la escena y la camara.
       // Esta función la creamos nosotros, no existe antes.
       function animate(sphere, renderer, scene, camera) {
          scene.simulate();
          renderer.render(scene, camera);

          requestAnimationFrame(function() {
             animate(sphere, renderer, scene, camera);
          });
       }

       // Función para añadir luz a la escena. PRUEBA: LUZ DIRECCIONAL.
       // Si no añadirmos ninguna luz, se ve un canvas negro.
       function getLight() {
          var light = new THREE.DirectionalLight();
          light.position.set(4, 4, 4);
          light.castShadow = true;
          light.shadow.camera.near = 0;
          light.shadow.camera.far = 16;
          light.shadow.camera.left = -8;
          light.shadow.camera.right = 5;
          light.shadow.camera.top = 10;
          light.shadow.camera.bottom = -10;
          light.shadow.mapSize.width = 4096;
          light.shadow.mapSize.height = 4096;
          return light;
       }

       // Para cada tipo de objeto que vamos a añadir a la escena creamos una funcion,
       // asi se utilizo un objeto mas de una vez, solo necesito llamar a la funcion para
       // definir ese nuevo objeto y no tener que repetir codigo innecesariamente.

       // Funcion para añadir la textura de madera a los objetos.
       function getWoodMaterial() {
          var texture = new THREE.TextureLoader().load("wood.png");
          var material = new THREE.MeshPhysicalMaterial({
             map : texture
          });
          material.map.wrapS = material.map.wrapT = THREE.RepeatWrapping;
          material.map.repeat.set(4, 4);
          material.side = THREE.DoubleSide;
          return material;
       }

       // Objeto Plano (Suelo)
       function getFloor() {
          var geometry = new THREE.PlaneGeometry(15, 20);
          var mesh = new Physijs.BoxMesh(geometry, getWoodMaterial(), 0);
          mesh.receiveShadow = true;
          mesh.name = "floor";
          return mesh;
       }

       // Objeto hexaedro (Bordes, CPU y Usuario)
       // A esta funcion le paso los parámetro:
       // - position: left, right, top, down
       // - x, y, z: ancho, largo y alto del hexaedro(cubo)
       // - posX, posY, posZ: coordenadas donde va colocado el hexaedro dentro
       //                     del canvas.
       function getBorder(name, x, y, z, posX, posY, posZ) {
          var geometry = new THREE.BoxGeometry(x, y, z);
          var mesh = new Physijs.BoxMesh(geometry, getWoodMaterial(), 0);
          mesh.receiveShadow = true;
          mesh.position.set(posX, posY, posZ);
          mesh.name = name;
          return mesh;
       }

       // Objeto Esfera (Pelota)
       function getSphere() {
          var geometry = new THREE.SphereGeometry(1, 20, 20);
          var material = new THREE.MeshNormalMaterial();
          var mesh = new Physijs.BoxMesh(geometry, material);
          mesh.position.z = 1;
          mesh.castShadow = true;
          mesh.name = "sphere";
          // Comprobación de que se detecta la colisión y sobre que objeto
          // se ha detectado.
          mesh.addEventListener('collision', function(otherObject) {
             console.log(otherObject.name);
          });

          return mesh;
       }
    </script>
  </head>

  <body onload="init()">
  </body>

</html>
